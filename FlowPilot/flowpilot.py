import os
import re
import inspect
from inspect import isfunction
import json
from typing import Callable, Dict, List, Optional, Union, Any
from functools import wraps
import logging
from tqdm import tqdm
import pandas as pd


class CategoryRegister:
    def __init__(self, categories: List[str]):
        self.categories = categories
        self.functions: Dict[str, Dict[str, Optional[str]]] = {
            category: {} for category in categories
        }

    def is_valid_category(self, category_name: str) -> bool:
        """Check if the given category name is valid."""
        return category_name in self.categories

    def create_new_category(self, name: str) -> None:
        """Create a new category."""
        if name in self.categories:
            print(f"Category '{name}' already exists.")
        else:
            self.categories.append(name)
            self.functions[name] = {}

    def register_function(self, category: str, comment: Optional[str] = None) -> Callable:
        """Register a function in the specified category."""

        def decorator(func: Callable) -> Callable:
            func_name = func.__name__
            func.__category__ = category
            self.functions[category][func_name] = comment
            return func

        return decorator
    
    def display_functions(self) -> None:
        """Display the functions registered in all categories."""
        function_data: Dict[str, Union[str, Dict[str, List[Dict[str, str]]]]] = {
            "functions": {},
        }
        function_data["functions"] = {
            category: [
                {"name": func_name, "comment": comment or "no comment"}
                for func_name, comment in functions.items()
            ]
            for category, functions in self.functions.items()
            if functions
        }
        print(json.dumps(function_data, indent=4))
        


class Project:
    def __init__(self, project_name: str):
        self.project_name = project_name
        self._create_project_directory()

    def _create_project_directory(self) -> None:
        """Create the project directory."""
        if not os.path.exists(self.project_name):
            os.makedirs(self.project_name)
            
    def _generate_function_docstring(self, func: Callable, comment: Optional[str] = None) -> str:
        signature = inspect.signature(func)
        input_types = {
            key: param.annotation
            for key, param in signature.parameters.items()
            if param.annotation != inspect.Parameter.empty
        }
        output_type = (
            signature.return_annotation
            if signature.return_annotation != inspect.Signature.empty
            else "Any"
        )
        indent = " " * 4

        docstring_lines = [
            f"{comment or 'No description'}",
            "",
            "Input types:",
            *[f"{indent}{key}: {value}" for key, value in input_types.items()],
            "",
            f"Output type: {output_type}",
        ]
        indented_docstring = "\n".join([indent + line for line in docstring_lines])

        return indented_docstring

    @staticmethod
    def _remove_decorator(func_str: str) -> str:
        """Remove the decorator from the function source code."""
        pattern = r"@\w+\.[a-z_]+\(.+?\)\n"
        match = re.search(pattern, func_str)
        if match:
            func_str = func_str[: match.start()] + func_str[match.end() :]
        return func_str
    
    @staticmethod
    def _get_import_statements(func_str: str) -> str:
        """Get the import statements from the function source code."""
        pattern = r"^(?:from .* import .*|import .*)$"
        import_statements = re.findall(pattern, func_str, re.MULTILINE)
        return "\n".join(import_statements)


    def _create_script_file(self, category_name: str, functions: Dict[str, Optional[str]], generate_docstrings: bool = False) -> None:
        """Create a script file for the given category."""
        category_path = os.path.join(self.project_name, category_name)
        os.makedirs(category_path, exist_ok=True)
        file_path = os.path.join(category_path, f"{category_name}.py")
        with open(file_path, "w") as f:
            f.write("# This file was generated by FlowPilot\n\n")
            imports = set()
            for func_name, _ in functions.items():
                func = globals().get(func_name)
                source = self._remove_decorator(inspect.getsource(func))
                imports.update(self._get_import_statements(source).splitlines())
            f.write("\n".join(sorted(imports)) + "\n\n")

            for func_name, comment in functions.items():
                func = globals().get(func_name)
                source = self._remove_decorator(inspect.getsource(func))
                if generate_docstrings:
                    docstring = self._generate_function_docstring(func, comment)
                    source_lines = source.splitlines()
                    indent = " " * 4  # Change the number to adjust the indentation size
                    source_lines.insert(1, f'{indent}"""\n{docstring}\n{indent}"""')
                    source = "\n".join(source_lines)
                f.write(f"{source}\n\n")


    def compile_scripts(self, categories: List[str], functions: Dict[str, Dict[str, Optional[str]]], category: str = "all", generate_docstrings: bool = False) -> str:
        """Compile scripts for the specified category or all categories."""
        if category == "all":
            compile_categories = categories
        elif not category in categories:
            raise ValueError(f"{category} is not a valid category name.")
        else:
            compile_categories = [category]

        for category_name in compile_categories:
            self._create_script_file(category_name, functions[category_name], generate_docstrings)

        return "SUCCESS"

class FlowPilot:
    def __init__(self, project_name: str):
        categories = ["data_reader", "data_transformer", "data_writer", "test"]
        self.project_name = project_name
        self.category_register = CategoryRegister(categories)
        self.project = Project(self.project_name)

        self._create_shortcuts_for_categories(categories)
    

    def _create_shortcuts_for_categories(self, categories: List[str]) -> None:
        """Create shortcuts for registering functions in categories."""
        for category in categories:
            setattr(self, category, lambda comment=None, cat=category: self.register_function(cat, comment))

    def create_new_category(self, name: str) -> None:
        """Create a new category and its shortcut."""
        self.category_register.create_new_category(name)
        self._create_shortcuts_for_categories([name])

    def register_function(self, category: str, comment: Optional[str] = None) -> Callable:
        """Register a function in a specific category."""
        return self.category_register.register_function(category, comment)

    def is_valid_category(self, category_name: str) -> bool:
        """Check if the category name is valid."""
        return self.category_register.is_valid_category(category_name)

    def custom(self, category_name: str, comment: Optional[str] = None) -> Callable:
        """Register a custom function in a category, creating the category if it does not exist."""
        if not self.category_register.is_valid_category(category_name):
            self.category_register.create_new_category(category_name)
        return self.category_register.register_function(category_name, comment)

    def display_functions(self) -> None:
        """Display the functions registered in all categories."""
        self.category_register.display_functions()

    def compile_scripts(self, category: str = "all", generate_docstrings: bool = False) -> str:
        """Compile scripts for the specified category or all categories."""
        return self.project.compile_scripts(
            self.category_register.categories,
            self.category_register.functions,
            category,
            generate_docstrings
        )
    
class DataQualityConstraints:
    @staticmethod
    def expect_column_types(columns_types, expect_mode='expect_or_drop'):
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                df = func(*args, **kwargs)
                for column, expected_type in columns_types.items():
                    if not pd.api.types.is_dtype_equal(df[column].dtype, expected_type):
                        if expect_mode == 'expect_or_drop':
                            df = df[df[column].notna()]
                        elif expect_mode == 'expect_but_allow':
                            continue
                        elif expect_mode == 'expect_or_fail':
                            raise ValueError(f"Column '{column}' is not of expected type '{expected_type}'.")
                return df
            return wrapper
        return decorator
            
    
class Pipeline:
    def __init__(self, flow_pilot: FlowPilot):
        self.flow_pilot = flow_pilot
        self.steps = []

    def add_step(self, category: str, func: Callable, *args, **kwargs) -> None:
        self._validate_function_category(func, category)
        self.steps.append((func, args, kwargs))

    def _validate_function_category(self, func: Callable, category: str) -> None:
        """Validate that the function belongs to the specified category."""
        if not hasattr(func, "__category__"):
            raise ValueError(f"Function '{func.__name__}' is not registered in any category.")
        if func.__category__ != category:
            raise ValueError(f"Function '{func.__name__}' does not belong to category '{category}'.")

    def execute(self) -> Any:
        data = None
        for step, step_args, step_kwargs in self.steps:
            if data is None:
                data = step(*step_args, **step_kwargs)
            else:
                data = step(data, *step_args, **step_kwargs)
        return data
    
    def show_pipeline_steps(self) -> None:
        """Display the logical flow of the functions in the pipeline."""
        if not self.steps:
            print("The pipeline is empty.")
            return

        print("Pipeline steps:")
        for i, (step, step_args, step_kwargs) in enumerate(self.steps, start=1):
            step_category = step.__category__
            step_name = step.__name__
            step_args_str = ", ".join(map(str, step_args)) if step_args else ""
            step_kwargs_str = ", ".join(f"{k}={v}" for k, v in step_kwargs.items()) if step_kwargs else ""
            step_params_str = step_args_str + (", " if step_args_str and step_kwargs_str else "") + step_kwargs_str

            print(f"{i}. [{step_category}] {step_name}({step_params_str})")
            
    def get_pipeline_steps_json(self) -> str:
        
        """Return the pipeline steps as a JSON string."""
        steps_data = [
            {"name": step.__name__, "category": step.__category__}
            for step, _, _ in self.steps
        ]
        return json.dumps(steps_data)