import os
import re
import inspect
import json
from typing import Callable, Dict, List, Optional, Union


class CategoryRegister:
    def __init__(self, categories: List[str]):
        self.categories = categories
        self.functions: Dict[str, Dict[str, Optional[str]]] = {
            category: {} for category in categories
        }

    def is_valid_category(self, category_name: str) -> bool:
        """Check if the given category name is valid."""
        return category_name in self.categories

    def create_new_category(self, name: str) -> None:
        """Create a new category."""
        if name in self.categories:
            print(f"Category '{name}' already exists.")
        else:
            self.categories.append(name)
            self.functions[name] = {}

    def register_function(self, category: str, comment: Optional[str] = None) -> Callable:
        """Register a function in the specified category."""

        def decorator(func: Callable) -> Callable:
            func_name = func.__name__
            func.__category__ = category
            self.functions[category][func_name] = comment
            return func

        return decorator

    def display_functions(self) -> None:
        """Display the functions registered in all categories."""
        function_data: Dict[str, Union[str, Dict[str, List[Dict[str, str]]]]] = {
            "functions": {},
        }
        function_data["functions"] = {
            category: [
                {"name": func_name, "comment": comment or "no comment"}
                for func_name, comment in functions.items()
            ]
            for category, functions in self.functions.items()
            if functions
        }
        print(json.dumps(function_data, indent=4))


class Project:
    def __init__(self, project_name: str):
        self.project_name = project_name
        self._create_project_directory()

    def _create_project_directory(self) -> None:
        """Create the project directory."""
        if not os.path.exists(self.project_name):
            os.makedirs(self.project_name)

    @staticmethod
    def _remove_decorator(func_str: str) -> str:
        """Remove the decorator from the function source code."""
        pattern = r"@\w+\.[a-z_]+\(.+?\)\n"
        match = re.search(pattern, func_str)
        if match:
            func_str = func_str[: match.start()] + func_str[match.end() :]
        return func_str

    def _create_script_file(self, category_name: str, functions: Dict[str, Optional[str]]) -> None:
        """Create a script file for the given category."""
        category_path = os.path.join(self.project_name, category_name)
        os.makedirs(category_path, exist_ok=True)
        file_path = os.path.join(category_path, f"{category_name}.py")
        with open(file_path, "w") as f:
            f.write("# This file was generated by FlowPilot\n\n")
            for func_name, _ in functions.items():
                func = globals().get(func_name)
                source = self._remove_decorator(inspect.getsource(func))
                f.write(f"{source}\n\n")


    def compile_scripts(self, categories: List[str], functions: Dict[str, Dict[str, Optional[str]]], category: str = "all") -> str:
        """Compile scripts for the specified category or all categories."""
        if category == "all":
            compile_categories = categories
        elif not category in categories:
            raise ValueError(f"{category} is not a valid category name.")
        else:
            compile_categories = [category]

        for category_name in compile_categories:
            self._create_script_file(category_name, functions[category_name])

        return "SUCCESS"

class FlowPilot:
    def __init__(self, project_name: str):
        categories = ["data_reader", "data_transformer", "data_writer", "test"]
        self.project_name = project_name
        self.category_register = CategoryRegister(categories)
        self.project = Project(self.project_name)

        self._create_shortcuts_for_categories(categories)

    def _create_shortcuts_for_categories(self, categories: List[str]) -> None:
        """Create shortcuts for registering functions in categories."""
        for category in categories:
            setattr(self, category, lambda comment=None, cat=category: self.register_function(cat, comment))

    def create_new_category(self, name: str) -> None:
        """Create a new category and its shortcut."""
        self.category_register.create_new_category(name)
        self._create_shortcuts_for_categories([name])

    def register_function(self, category: str, comment: Optional[str] = None) -> Callable:
        """Register a function in a specific category."""
        return self.category_register.register_function(category, comment)

    def is_valid_category(self, category_name: str) -> bool:
        """Check if the category name is valid."""
        return self.category_register.is_valid_category(category_name)

    def custom(self, category_name: str, comment: Optional[str] = None) -> Callable:
        """Register a custom function in a category, creating the category if it does not exist."""
        if not self.category_register.is_valid_category(category_name):
            self.category_register.create_new_category(category_name)
        return self.category_register.register_function(category_name, comment)

    def display_functions(self) -> None:
        """Display the functions registered in all categories."""
        self.category_register.display_functions()

    def compile_scripts(self, category: str = "all") -> str:
        """Compile scripts for the specified category or all categories."""
        return self.project.compile_scripts(self.category_register.categories, self.category_register.functions, category)
    
    
class Pipeline:
    def __init__(self, flow_pilot: FlowPilot):
        self.flow_pilot = flow_pilot
        self.steps = []

    def add_step(self, category: str, function_name: str) -> None:
        if not self.flow_pilot.is_valid_category(category):
            raise ValueError(f"{category} is not a valid category name.")
        
        if function_name not in self.flow_pilot.category_register.functions[category]:
            raise ValueError(f"{function_name} is not a valid function name in category {category}.")
        
        func = globals().get(function_name)
        self.steps.append(func)

    def execute(self, *args, **kwargs):
        data = args[0]
        for step in self.steps:
            data = step(data, **kwargs)
        return data

